package main

import (
	"fmt"
	"io/ioutil"
	"math/rand"
	"os"
	"strings"
	"time"
)

// Create a new type of deck
// which is a slice of strings

type deck []string // deck kind of extends or borrows the behaviour of the slice of string

func newDeck() deck {
	cards := deck{}

	cardSuits := []string{"Spades", "Diamonds", "Hearts", "Club"}

	cardValues := []string{"Ace", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Jack", "Queen", "King"}

	for _, suit := range cardSuits { // We use _ since we are telling go that we are not using that variable and just dont care about it
		for _, value := range cardValues {
			cards = append(cards, value+" of "+suit)
		}
	}

	return cards
}

func (d deck) print() { // 'd deck' is seen as a reciever on the function. The actual copy of the deck
	// we are working with is available in the function as a variable called 'd'. Every variable of type
	// deck can call this function on itself.

	for i, Card := range d { // 'i' is the index of the element in the array

		// 'card' is the current card we are iterating over

		// range takes the slice of cards and loops over it

		fmt.Println(i, Card)

	}

}

func deal(d deck, handSize int) (deck, deck) { //Returning two separate values where one is the hand of cards while the other is the complement of the previous

	return d[:handSize], d[handSize:]
}

func (d deck) toString() string {

	//Takes a deck and returns a complete string to it.
	// fmt.Println("Deck")
	// fmt.Println(d)
	// fmt.Println("Slice of String")
	// fmt.Println([]string(d))
	// fmt.Println("Comma separated")
	return strings.Join([]string(d), ",") //Takes our slice of string and joins it into one string separated by comma

}

func (d deck) saveToFile(filename string) error {

	//WriteFile writes data to a file named by filename. If the file does not exist, WriteFile creates it with permissions otherwise trunates it before writing

	return ioutil.WriteFile(filename, []byte(d.toString()), 0666) //Permissions are set to : anyone can read or write the file

}

func newDeckFromFile(filename string) deck {

	bs, err := ioutil.ReadFile(filename) // bs(byte slice) returns the string of characters separated by comma and err is the error object returned

	if err != nil {

		// Option #1 - log the error and return a call to newDeck() so that the user has a deck to work with if the read to the hard drive fails
		// Option #2 - log the error and entirely quit the program

		fmt.Println("Error:", err)

		os.Exit(1) //The program terminates immediately
	}

	//Converting the byte slice obtained from the file into string to obtain the deck of cards

	s := strings.Split(string(bs), ",") // Type coversioned bs is then converted into a slice of strings

	return deck(s)
}

func (d deck) shuffle() {

	source := rand.NewSource(time.Now().UnixNano()) //Similar to a seed value for randomisation

	//UnixNano returns unix time, the no of nanoseconds elapsed since Jan 1 1970 UTC.The result is undefined if not represented by an int64

	r := rand.New(source) //Returns a new rand that uses random values from the source to generate other random values

	for index := range d {

		// newPosition := rand.Intn(len(d) - 1) //Intn returns as an integer, a non-negative pseudo random number in [0,n) from the default source

		//The above has a tiny issue that the random numbers generated by go will always start with the same sequence and thus after each run it will output the same randomised series.

		//Thus we do the following

		newPosition := r.Intn(len(d) - 1)

		d[index], d[newPosition] = d[newPosition], d[index] // Swapping the two values (exchanging)
	}
}
